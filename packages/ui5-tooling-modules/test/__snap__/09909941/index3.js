sap.ui.define(['exports'], (function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var src = {};

	var utils$1 = {};

	var diag$1 = {};

	var ComponentLogger = {};

	var globalUtils = {};

	var browser = {};

	var globalThis$1 = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(globalThis$1, "__esModule", { value: true });
	globalThis$1._globalThis = void 0;
	// Updates to this file should also be replicated to @opentelemetry/core too.
	/**
	 * - globalThis (New standard)
	 * - self (Will return the current window instance for supported browsers)
	 * - window (fallback for older browser implementations)
	 * - global (NodeJS implementation)
	 * - <object> (When all else fails)
	 */
	/** only globals that common to node and browsers are allowed */
	// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
	globalThis$1._globalThis = typeof globalThis === 'object'
	    ? globalThis
	    : typeof self === 'object'
	        ? self
	        : typeof window === 'object'
	            ? window
	            : typeof commonjsGlobal === 'object'
	                ? commonjsGlobal
	                : {};

	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(globalThis$1, exports);
		
	} (browser));

	var version = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(version, "__esModule", { value: true });
	version.VERSION = void 0;
	// this is autogenerated file, see scripts/version-update.js
	version.VERSION = '1.9.0';

	var semver = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(semver, "__esModule", { value: true });
	semver.isCompatible = semver._makeCompatibilityCheck = void 0;
	const version_1$1 = version;
	const re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
	/**
	 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
	 *
	 * The returned function has the following semantics:
	 * - Exact match is always compatible
	 * - Major versions must match exactly
	 *    - 1.x package cannot use global 2.x package
	 *    - 2.x package cannot use global 1.x package
	 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
	 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
	 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
	 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
	 * - Patch and build tag differences are not considered at this time
	 *
	 * @param ownVersion version which should be checked against
	 */
	function _makeCompatibilityCheck(ownVersion) {
	    const acceptedVersions = new Set([ownVersion]);
	    const rejectedVersions = new Set();
	    const myVersionMatch = ownVersion.match(re);
	    if (!myVersionMatch) {
	        // we cannot guarantee compatibility so we always return noop
	        return () => false;
	    }
	    const ownVersionParsed = {
	        major: +myVersionMatch[1],
	        minor: +myVersionMatch[2],
	        patch: +myVersionMatch[3],
	        prerelease: myVersionMatch[4],
	    };
	    // if ownVersion has a prerelease tag, versions must match exactly
	    if (ownVersionParsed.prerelease != null) {
	        return function isExactmatch(globalVersion) {
	            return globalVersion === ownVersion;
	        };
	    }
	    function _reject(v) {
	        rejectedVersions.add(v);
	        return false;
	    }
	    function _accept(v) {
	        acceptedVersions.add(v);
	        return true;
	    }
	    return function isCompatible(globalVersion) {
	        if (acceptedVersions.has(globalVersion)) {
	            return true;
	        }
	        if (rejectedVersions.has(globalVersion)) {
	            return false;
	        }
	        const globalVersionMatch = globalVersion.match(re);
	        if (!globalVersionMatch) {
	            // cannot parse other version
	            // we cannot guarantee compatibility so we always noop
	            return _reject(globalVersion);
	        }
	        const globalVersionParsed = {
	            major: +globalVersionMatch[1],
	            minor: +globalVersionMatch[2],
	            patch: +globalVersionMatch[3],
	            prerelease: globalVersionMatch[4],
	        };
	        // if globalVersion has a prerelease tag, versions must match exactly
	        if (globalVersionParsed.prerelease != null) {
	            return _reject(globalVersion);
	        }
	        // major versions must match
	        if (ownVersionParsed.major !== globalVersionParsed.major) {
	            return _reject(globalVersion);
	        }
	        if (ownVersionParsed.major === 0) {
	            if (ownVersionParsed.minor === globalVersionParsed.minor &&
	                ownVersionParsed.patch <= globalVersionParsed.patch) {
	                return _accept(globalVersion);
	            }
	            return _reject(globalVersion);
	        }
	        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
	            return _accept(globalVersion);
	        }
	        return _reject(globalVersion);
	    };
	}
	semver._makeCompatibilityCheck = _makeCompatibilityCheck;
	/**
	 * Test an API version to see if it is compatible with this API.
	 *
	 * - Exact match is always compatible
	 * - Major versions must match exactly
	 *    - 1.x package cannot use global 2.x package
	 *    - 2.x package cannot use global 1.x package
	 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
	 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
	 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
	 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
	 * - Patch and build tag differences are not considered at this time
	 *
	 * @param version version of the API requesting an instance of the global API
	 */
	semver.isCompatible = _makeCompatibilityCheck(version_1$1.VERSION);

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(globalUtils, "__esModule", { value: true });
	globalUtils.unregisterGlobal = globalUtils.getGlobal = globalUtils.registerGlobal = void 0;
	const platform_1 = browser;
	const version_1 = version;
	const semver_1 = semver;
	const major = version_1.VERSION.split('.')[0];
	const GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
	const _global = platform_1._globalThis;
	function registerGlobal(type, instance, diag, allowOverride = false) {
	    var _a;
	    const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
	        version: version_1.VERSION,
	    });
	    if (!allowOverride && api[type]) {
	        // already registered an API of this type
	        const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
	        diag.error(err.stack || err.message);
	        return false;
	    }
	    if (api.version !== version_1.VERSION) {
	        // All registered APIs must be of the same version exactly
	        const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
	        diag.error(err.stack || err.message);
	        return false;
	    }
	    api[type] = instance;
	    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
	    return true;
	}
	globalUtils.registerGlobal = registerGlobal;
	function getGlobal(type) {
	    var _a, _b;
	    const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
	    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
	        return;
	    }
	    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
	}
	globalUtils.getGlobal = getGlobal;
	function unregisterGlobal(type, diag) {
	    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
	    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
	    if (api) {
	        delete api[type];
	    }
	}
	globalUtils.unregisterGlobal = unregisterGlobal;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(ComponentLogger, "__esModule", { value: true });
	ComponentLogger.DiagComponentLogger = void 0;
	const global_utils_1$5 = globalUtils;
	/**
	 * Component Logger which is meant to be used as part of any component which
	 * will add automatically additional namespace in front of the log message.
	 * It will then forward all message to global diag logger
	 * @example
	 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
	 * cLogger.debug('test');
	 * // @opentelemetry/instrumentation-http test
	 */
	class DiagComponentLogger {
	    constructor(props) {
	        this._namespace = props.namespace || 'DiagComponentLogger';
	    }
	    debug(...args) {
	        return logProxy('debug', this._namespace, args);
	    }
	    error(...args) {
	        return logProxy('error', this._namespace, args);
	    }
	    info(...args) {
	        return logProxy('info', this._namespace, args);
	    }
	    warn(...args) {
	        return logProxy('warn', this._namespace, args);
	    }
	    verbose(...args) {
	        return logProxy('verbose', this._namespace, args);
	    }
	}
	ComponentLogger.DiagComponentLogger = DiagComponentLogger;
	function logProxy(funcName, namespace, args) {
	    const logger = (0, global_utils_1$5.getGlobal)('diag');
	    // shortcut if logger not set
	    if (!logger) {
	        return;
	    }
	    args.unshift(namespace);
	    return logger[funcName](...args);
	}

	var logLevelLogger = {};

	var types = {};

	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.DiagLogLevel = void 0;
		(function (DiagLogLevel) {
		    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
		    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
		    /** Identifies an error scenario */
		    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
		    /** Identifies a warning scenario */
		    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
		    /** General informational log message */
		    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
		    /** General debug log message */
		    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
		    /**
		     * Detailed trace level logging should only be used for development, should only be set
		     * in a development environment.
		     */
		    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
		    /** Used to set the logging level to include all logging */
		    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
		})(exports.DiagLogLevel || (exports.DiagLogLevel = {}));
		
	} (types));

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(logLevelLogger, "__esModule", { value: true });
	logLevelLogger.createLogLevelDiagLogger = void 0;
	const types_1$1 = types;
	function createLogLevelDiagLogger(maxLevel, logger) {
	    if (maxLevel < types_1$1.DiagLogLevel.NONE) {
	        maxLevel = types_1$1.DiagLogLevel.NONE;
	    }
	    else if (maxLevel > types_1$1.DiagLogLevel.ALL) {
	        maxLevel = types_1$1.DiagLogLevel.ALL;
	    }
	    // In case the logger is null or undefined
	    logger = logger || {};
	    function _filterFunc(funcName, theLevel) {
	        const theFunc = logger[funcName];
	        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
	            return theFunc.bind(logger);
	        }
	        return function () { };
	    }
	    return {
	        error: _filterFunc('error', types_1$1.DiagLogLevel.ERROR),
	        warn: _filterFunc('warn', types_1$1.DiagLogLevel.WARN),
	        info: _filterFunc('info', types_1$1.DiagLogLevel.INFO),
	        debug: _filterFunc('debug', types_1$1.DiagLogLevel.DEBUG),
	        verbose: _filterFunc('verbose', types_1$1.DiagLogLevel.VERBOSE),
	    };
	}
	logLevelLogger.createLogLevelDiagLogger = createLogLevelDiagLogger;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(diag$1, "__esModule", { value: true });
	diag$1.DiagAPI = void 0;
	const ComponentLogger_1 = ComponentLogger;
	const logLevelLogger_1 = logLevelLogger;
	const types_1 = types;
	const global_utils_1$4 = globalUtils;
	const API_NAME$4 = 'diag';
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry internal
	 * diagnostic API
	 */
	class DiagAPI {
	    /**
	     * Private internal constructor
	     * @private
	     */
	    constructor() {
	        function _logProxy(funcName) {
	            return function (...args) {
	                const logger = (0, global_utils_1$4.getGlobal)('diag');
	                // shortcut if logger not set
	                if (!logger)
	                    return;
	                return logger[funcName](...args);
	            };
	        }
	        // Using self local variable for minification purposes as 'this' cannot be minified
	        const self = this;
	        // DiagAPI specific functions
	        const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
	            var _a, _b, _c;
	            if (logger === self) {
	                // There isn't much we can do here.
	                // Logging to the console might break the user application.
	                // Try to log to self. If a logger was previously registered it will receive the log.
	                const err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
	                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
	                return false;
	            }
	            if (typeof optionsOrLogLevel === 'number') {
	                optionsOrLogLevel = {
	                    logLevel: optionsOrLogLevel,
	                };
	            }
	            const oldLogger = (0, global_utils_1$4.getGlobal)('diag');
	            const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger);
	            // There already is an logger registered. We'll let it know before overwriting it.
	            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
	                const stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';
	                oldLogger.warn(`Current logger will be overwritten from ${stack}`);
	                newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
	            }
	            return (0, global_utils_1$4.registerGlobal)('diag', newLogger, self, true);
	        };
	        self.setLogger = setLogger;
	        self.disable = () => {
	            (0, global_utils_1$4.unregisterGlobal)(API_NAME$4, self);
	        };
	        self.createComponentLogger = (options) => {
	            return new ComponentLogger_1.DiagComponentLogger(options);
	        };
	        self.verbose = _logProxy('verbose');
	        self.debug = _logProxy('debug');
	        self.info = _logProxy('info');
	        self.warn = _logProxy('warn');
	        self.error = _logProxy('error');
	    }
	    /** Get the singleton instance of the DiagAPI API */
	    static instance() {
	        if (!this._instance) {
	            this._instance = new DiagAPI();
	        }
	        return this._instance;
	    }
	}
	diag$1.DiagAPI = DiagAPI;

	var baggageImpl = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(baggageImpl, "__esModule", { value: true });
	baggageImpl.BaggageImpl = void 0;
	class BaggageImpl {
	    constructor(entries) {
	        this._entries = entries ? new Map(entries) : new Map();
	    }
	    getEntry(key) {
	        const entry = this._entries.get(key);
	        if (!entry) {
	            return undefined;
	        }
	        return Object.assign({}, entry);
	    }
	    getAllEntries() {
	        return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
	    }
	    setEntry(key, entry) {
	        const newBaggage = new BaggageImpl(this._entries);
	        newBaggage._entries.set(key, entry);
	        return newBaggage;
	    }
	    removeEntry(key) {
	        const newBaggage = new BaggageImpl(this._entries);
	        newBaggage._entries.delete(key);
	        return newBaggage;
	    }
	    removeEntries(...keys) {
	        const newBaggage = new BaggageImpl(this._entries);
	        for (const key of keys) {
	            newBaggage._entries.delete(key);
	        }
	        return newBaggage;
	    }
	    clear() {
	        return new BaggageImpl();
	    }
	}
	baggageImpl.BaggageImpl = BaggageImpl;

	var symbol = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(symbol, "__esModule", { value: true });
	symbol.baggageEntryMetadataSymbol = void 0;
	/**
	 * Symbol used to make BaggageEntryMetadata an opaque type
	 */
	symbol.baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(utils$1, "__esModule", { value: true });
	utils$1.baggageEntryMetadataFromString = utils$1.createBaggage = void 0;
	const diag_1$5 = diag$1;
	const baggage_impl_1 = baggageImpl;
	const symbol_1 = symbol;
	const diag = diag_1$5.DiagAPI.instance();
	/**
	 * Create a new Baggage with optional entries
	 *
	 * @param entries An array of baggage entries the new baggage should contain
	 */
	function createBaggage(entries = {}) {
	    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
	}
	utils$1.createBaggage = createBaggage;
	/**
	 * Create a serializable BaggageEntryMetadata object from a string.
	 *
	 * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
	 *
	 */
	function baggageEntryMetadataFromString(str) {
	    if (typeof str !== 'string') {
	        diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
	        str = '';
	    }
	    return {
	        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
	        toString() {
	            return str;
	        },
	    };
	}
	utils$1.baggageEntryMetadataFromString = baggageEntryMetadataFromString;

	var context$1 = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(context$1, "__esModule", { value: true });
	context$1.ROOT_CONTEXT = context$1.createContextKey = void 0;
	/** Get a key to uniquely identify a context value */
	function createContextKey(description) {
	    // The specification states that for the same input, multiple calls should
	    // return different keys. Due to the nature of the JS dependency management
	    // system, this creates problems where multiple versions of some package
	    // could hold different keys for the same property.
	    //
	    // Therefore, we use Symbol.for which returns the same key for the same input.
	    return Symbol.for(description);
	}
	context$1.createContextKey = createContextKey;
	class BaseContext {
	    /**
	     * Construct a new context which inherits values from an optional parent context.
	     *
	     * @param parentContext a context from which to inherit values
	     */
	    constructor(parentContext) {
	        // for minification
	        const self = this;
	        self._currentContext = parentContext ? new Map(parentContext) : new Map();
	        self.getValue = (key) => self._currentContext.get(key);
	        self.setValue = (key, value) => {
	            const context = new BaseContext(self._currentContext);
	            context._currentContext.set(key, value);
	            return context;
	        };
	        self.deleteValue = (key) => {
	            const context = new BaseContext(self._currentContext);
	            context._currentContext.delete(key);
	            return context;
	        };
	    }
	}
	/** The root context is used as the default parent context when there is no active context */
	context$1.ROOT_CONTEXT = new BaseContext();

	var consoleLogger = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(consoleLogger, "__esModule", { value: true });
	consoleLogger.DiagConsoleLogger = void 0;
	const consoleMap = [
	    { n: 'error', c: 'error' },
	    { n: 'warn', c: 'warn' },
	    { n: 'info', c: 'info' },
	    { n: 'debug', c: 'debug' },
	    { n: 'verbose', c: 'trace' },
	];
	/**
	 * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
	 * If you want to limit the amount of logging to a specific level or lower use the
	 * {@link createLogLevelDiagLogger}
	 */
	class DiagConsoleLogger {
	    constructor() {
	        function _consoleFunc(funcName) {
	            return function (...args) {
	                if (console) {
	                    // Some environments only expose the console when the F12 developer console is open
	                    // eslint-disable-next-line no-console
	                    let theFunc = console[funcName];
	                    if (typeof theFunc !== 'function') {
	                        // Not all environments support all functions
	                        // eslint-disable-next-line no-console
	                        theFunc = console.log;
	                    }
	                    // One last final check
	                    if (typeof theFunc === 'function') {
	                        return theFunc.apply(console, args);
	                    }
	                }
	            };
	        }
	        for (let i = 0; i < consoleMap.length; i++) {
	            this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
	        }
	    }
	}
	consoleLogger.DiagConsoleLogger = DiagConsoleLogger;

	var NoopMeter = {};

	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
		/**
		 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
		 * constant NoopMetrics for all of its methods.
		 */
		class NoopMeter {
		    constructor() { }
		    /**
		     * @see {@link Meter.createGauge}
		     */
		    createGauge(_name, _options) {
		        return exports.NOOP_GAUGE_METRIC;
		    }
		    /**
		     * @see {@link Meter.createHistogram}
		     */
		    createHistogram(_name, _options) {
		        return exports.NOOP_HISTOGRAM_METRIC;
		    }
		    /**
		     * @see {@link Meter.createCounter}
		     */
		    createCounter(_name, _options) {
		        return exports.NOOP_COUNTER_METRIC;
		    }
		    /**
		     * @see {@link Meter.createUpDownCounter}
		     */
		    createUpDownCounter(_name, _options) {
		        return exports.NOOP_UP_DOWN_COUNTER_METRIC;
		    }
		    /**
		     * @see {@link Meter.createObservableGauge}
		     */
		    createObservableGauge(_name, _options) {
		        return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
		    }
		    /**
		     * @see {@link Meter.createObservableCounter}
		     */
		    createObservableCounter(_name, _options) {
		        return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
		    }
		    /**
		     * @see {@link Meter.createObservableUpDownCounter}
		     */
		    createObservableUpDownCounter(_name, _options) {
		        return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
		    }
		    /**
		     * @see {@link Meter.addBatchObservableCallback}
		     */
		    addBatchObservableCallback(_callback, _observables) { }
		    /**
		     * @see {@link Meter.removeBatchObservableCallback}
		     */
		    removeBatchObservableCallback(_callback) { }
		}
		exports.NoopMeter = NoopMeter;
		class NoopMetric {
		}
		exports.NoopMetric = NoopMetric;
		class NoopCounterMetric extends NoopMetric {
		    add(_value, _attributes) { }
		}
		exports.NoopCounterMetric = NoopCounterMetric;
		class NoopUpDownCounterMetric extends NoopMetric {
		    add(_value, _attributes) { }
		}
		exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
		class NoopGaugeMetric extends NoopMetric {
		    record(_value, _attributes) { }
		}
		exports.NoopGaugeMetric = NoopGaugeMetric;
		class NoopHistogramMetric extends NoopMetric {
		    record(_value, _attributes) { }
		}
		exports.NoopHistogramMetric = NoopHistogramMetric;
		class NoopObservableMetric {
		    addCallback(_callback) { }
		    removeCallback(_callback) { }
		}
		exports.NoopObservableMetric = NoopObservableMetric;
		class NoopObservableCounterMetric extends NoopObservableMetric {
		}
		exports.NoopObservableCounterMetric = NoopObservableCounterMetric;
		class NoopObservableGaugeMetric extends NoopObservableMetric {
		}
		exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
		class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
		}
		exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
		exports.NOOP_METER = new NoopMeter();
		// Synchronous instruments
		exports.NOOP_COUNTER_METRIC = new NoopCounterMetric();
		exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric();
		exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
		exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
		// Asynchronous instruments
		exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
		exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
		exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
		/**
		 * Create a no-op Meter
		 */
		function createNoopMeter() {
		    return exports.NOOP_METER;
		}
		exports.createNoopMeter = createNoopMeter;
		
	} (NoopMeter));

	var Metric = {};

	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueType = void 0;
		(function (ValueType) {
		    ValueType[ValueType["INT"] = 0] = "INT";
		    ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
		})(exports.ValueType || (exports.ValueType = {}));
		
	} (Metric));

	var TextMapPropagator = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(TextMapPropagator, "__esModule", { value: true });
	TextMapPropagator.defaultTextMapSetter = TextMapPropagator.defaultTextMapGetter = void 0;
	TextMapPropagator.defaultTextMapGetter = {
	    get(carrier, key) {
	        if (carrier == null) {
	            return undefined;
	        }
	        return carrier[key];
	    },
	    keys(carrier) {
	        if (carrier == null) {
	            return [];
	        }
	        return Object.keys(carrier);
	    },
	};
	TextMapPropagator.defaultTextMapSetter = {
	    set(carrier, key, value) {
	        if (carrier == null) {
	            return;
	        }
	        carrier[key] = value;
	    },
	};

	var ProxyTracer$1 = {};

	var NoopTracer$1 = {};

	var context = {};

	var NoopContextManager$1 = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NoopContextManager$1, "__esModule", { value: true });
	NoopContextManager$1.NoopContextManager = void 0;
	const context_1$4 = context$1;
	class NoopContextManager {
	    active() {
	        return context_1$4.ROOT_CONTEXT;
	    }
	    with(_context, fn, thisArg, ...args) {
	        return fn.call(thisArg, ...args);
	    }
	    bind(_context, target) {
	        return target;
	    }
	    enable() {
	        return this;
	    }
	    disable() {
	        return this;
	    }
	}
	NoopContextManager$1.NoopContextManager = NoopContextManager;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(context, "__esModule", { value: true });
	context.ContextAPI = void 0;
	const NoopContextManager_1 = NoopContextManager$1;
	const global_utils_1$3 = globalUtils;
	const diag_1$4 = diag$1;
	const API_NAME$3 = 'context';
	const NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry Context API
	 */
	class ContextAPI {
	    /** Empty private constructor prevents end users from constructing a new instance of the API */
	    constructor() { }
	    /** Get the singleton instance of the Context API */
	    static getInstance() {
	        if (!this._instance) {
	            this._instance = new ContextAPI();
	        }
	        return this._instance;
	    }
	    /**
	     * Set the current context manager.
	     *
	     * @returns true if the context manager was successfully registered, else false
	     */
	    setGlobalContextManager(contextManager) {
	        return (0, global_utils_1$3.registerGlobal)(API_NAME$3, contextManager, diag_1$4.DiagAPI.instance());
	    }
	    /**
	     * Get the currently active context
	     */
	    active() {
	        return this._getContextManager().active();
	    }
	    /**
	     * Execute a function with an active context
	     *
	     * @param context context to be active during function execution
	     * @param fn function to execute in a context
	     * @param thisArg optional receiver to be used for calling fn
	     * @param args optional arguments forwarded to fn
	     */
	    with(context, fn, thisArg, ...args) {
	        return this._getContextManager().with(context, fn, thisArg, ...args);
	    }
	    /**
	     * Bind a context to a target function or event emitter
	     *
	     * @param context context to bind to the event emitter or function. Defaults to the currently active context
	     * @param target function or event emitter to bind
	     */
	    bind(context, target) {
	        return this._getContextManager().bind(context, target);
	    }
	    _getContextManager() {
	        return (0, global_utils_1$3.getGlobal)(API_NAME$3) || NOOP_CONTEXT_MANAGER;
	    }
	    /** Disable and remove the global context manager */
	    disable() {
	        this._getContextManager().disable();
	        (0, global_utils_1$3.unregisterGlobal)(API_NAME$3, diag_1$4.DiagAPI.instance());
	    }
	}
	context.ContextAPI = ContextAPI;

	var contextUtils = {};

	var NonRecordingSpan$1 = {};

	var invalidSpanConstants = {};

	var trace_flags = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.TraceFlags = void 0;
		(function (TraceFlags) {
		    /** Represents no flag set. */
		    TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
		    /** Bit to represent whether trace is sampled in trace flags. */
		    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
		})(exports.TraceFlags || (exports.TraceFlags = {}));
		
	} (trace_flags));

	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;
		const trace_flags_1 = trace_flags;
		exports.INVALID_SPANID = '0000000000000000';
		exports.INVALID_TRACEID = '00000000000000000000000000000000';
		exports.INVALID_SPAN_CONTEXT = {
		    traceId: exports.INVALID_TRACEID,
		    spanId: exports.INVALID_SPANID,
		    traceFlags: trace_flags_1.TraceFlags.NONE,
		};
		
	} (invalidSpanConstants));

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NonRecordingSpan$1, "__esModule", { value: true });
	NonRecordingSpan$1.NonRecordingSpan = void 0;
	const invalid_span_constants_1$1 = invalidSpanConstants;
	/**
	 * The NonRecordingSpan is the default {@link Span} that is used when no Span
	 * implementation is available. All operations are no-op including context
	 * propagation.
	 */
	class NonRecordingSpan {
	    constructor(_spanContext = invalid_span_constants_1$1.INVALID_SPAN_CONTEXT) {
	        this._spanContext = _spanContext;
	    }
	    // Returns a SpanContext.
	    spanContext() {
	        return this._spanContext;
	    }
	    // By default does nothing
	    setAttribute(_key, _value) {
	        return this;
	    }
	    // By default does nothing
	    setAttributes(_attributes) {
	        return this;
	    }
	    // By default does nothing
	    addEvent(_name, _attributes) {
	        return this;
	    }
	    addLink(_link) {
	        return this;
	    }
	    addLinks(_links) {
	        return this;
	    }
	    // By default does nothing
	    setStatus(_status) {
	        return this;
	    }
	    // By default does nothing
	    updateName(_name) {
	        return this;
	    }
	    // By default does nothing
	    end(_endTime) { }
	    // isRecording always returns false for NonRecordingSpan.
	    isRecording() {
	        return false;
	    }
	    // By default does nothing
	    recordException(_exception, _time) { }
	}
	NonRecordingSpan$1.NonRecordingSpan = NonRecordingSpan;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(contextUtils, "__esModule", { value: true });
	contextUtils.getSpanContext = contextUtils.setSpanContext = contextUtils.deleteSpan = contextUtils.setSpan = contextUtils.getActiveSpan = contextUtils.getSpan = void 0;
	const context_1$3 = context$1;
	const NonRecordingSpan_1$2 = NonRecordingSpan$1;
	const context_2$1 = context;
	/**
	 * span key
	 */
	const SPAN_KEY = (0, context_1$3.createContextKey)('OpenTelemetry Context Key SPAN');
	/**
	 * Return the span if one exists
	 *
	 * @param context context to get span from
	 */
	function getSpan(context) {
	    return context.getValue(SPAN_KEY) || undefined;
	}
	contextUtils.getSpan = getSpan;
	/**
	 * Gets the span from the current context, if one exists.
	 */
	function getActiveSpan() {
	    return getSpan(context_2$1.ContextAPI.getInstance().active());
	}
	contextUtils.getActiveSpan = getActiveSpan;
	/**
	 * Set the span on a context
	 *
	 * @param context context to use as parent
	 * @param span span to set active
	 */
	function setSpan(context, span) {
	    return context.setValue(SPAN_KEY, span);
	}
	contextUtils.setSpan = setSpan;
	/**
	 * Remove current span stored in the context
	 *
	 * @param context context to delete span from
	 */
	function deleteSpan(context) {
	    return context.deleteValue(SPAN_KEY);
	}
	contextUtils.deleteSpan = deleteSpan;
	/**
	 * Wrap span context in a NoopSpan and set as span in a new
	 * context
	 *
	 * @param context context to set active span on
	 * @param spanContext span context to be wrapped
	 */
	function setSpanContext(context, spanContext) {
	    return setSpan(context, new NonRecordingSpan_1$2.NonRecordingSpan(spanContext));
	}
	contextUtils.setSpanContext = setSpanContext;
	/**
	 * Get the span context of the span if it exists.
	 *
	 * @param context context to get values from
	 */
	function getSpanContext(context) {
	    var _a;
	    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
	}
	contextUtils.getSpanContext = getSpanContext;

	var spancontextUtils = {};

	Object.defineProperty(spancontextUtils, "__esModule", { value: true });
	spancontextUtils.wrapSpanContext = spancontextUtils.isSpanContextValid = spancontextUtils.isValidSpanId = spancontextUtils.isValidTraceId = void 0;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	const invalid_span_constants_1 = invalidSpanConstants;
	const NonRecordingSpan_1$1 = NonRecordingSpan$1;
	const VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
	const VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
	function isValidTraceId(traceId) {
	    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
	}
	spancontextUtils.isValidTraceId = isValidTraceId;
	function isValidSpanId(spanId) {
	    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
	}
	spancontextUtils.isValidSpanId = isValidSpanId;
	/**
	 * Returns true if this {@link SpanContext} is valid.
	 * @return true if this {@link SpanContext} is valid.
	 */
	function isSpanContextValid(spanContext) {
	    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
	}
	spancontextUtils.isSpanContextValid = isSpanContextValid;
	/**
	 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
	 *
	 * @param spanContext span context to be wrapped
	 * @returns a new non-recording {@link Span} with the provided context
	 */
	function wrapSpanContext(spanContext) {
	    return new NonRecordingSpan_1$1.NonRecordingSpan(spanContext);
	}
	spancontextUtils.wrapSpanContext = wrapSpanContext;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NoopTracer$1, "__esModule", { value: true });
	NoopTracer$1.NoopTracer = void 0;
	const context_1$2 = context;
	const context_utils_1$1 = contextUtils;
	const NonRecordingSpan_1 = NonRecordingSpan$1;
	const spancontext_utils_1$1 = spancontextUtils;
	const contextApi$1 = context_1$2.ContextAPI.getInstance();
	/**
	 * No-op implementations of {@link Tracer}.
	 */
	class NoopTracer {
	    // startSpan starts a noop span.
	    startSpan(name, options, context = contextApi$1.active()) {
	        const root = Boolean(options === null || options === void 0 ? void 0 : options.root);
	        if (root) {
	            return new NonRecordingSpan_1.NonRecordingSpan();
	        }
	        const parentFromContext = context && (0, context_utils_1$1.getSpanContext)(context);
	        if (isSpanContext(parentFromContext) &&
	            (0, spancontext_utils_1$1.isSpanContextValid)(parentFromContext)) {
	            return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
	        }
	        else {
	            return new NonRecordingSpan_1.NonRecordingSpan();
	        }
	    }
	    startActiveSpan(name, arg2, arg3, arg4) {
	        let opts;
	        let ctx;
	        let fn;
	        if (arguments.length < 2) {
	            return;
	        }
	        else if (arguments.length === 2) {
	            fn = arg2;
	        }
	        else if (arguments.length === 3) {
	            opts = arg2;
	            fn = arg3;
	        }
	        else {
	            opts = arg2;
	            ctx = arg3;
	            fn = arg4;
	        }
	        const parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi$1.active();
	        const span = this.startSpan(name, opts, parentContext);
	        const contextWithSpanSet = (0, context_utils_1$1.setSpan)(parentContext, span);
	        return contextApi$1.with(contextWithSpanSet, fn, undefined, span);
	    }
	}
	NoopTracer$1.NoopTracer = NoopTracer;
	function isSpanContext(spanContext) {
	    return (typeof spanContext === 'object' &&
	        typeof spanContext['spanId'] === 'string' &&
	        typeof spanContext['traceId'] === 'string' &&
	        typeof spanContext['traceFlags'] === 'number');
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(ProxyTracer$1, "__esModule", { value: true });
	ProxyTracer$1.ProxyTracer = void 0;
	const NoopTracer_1$1 = NoopTracer$1;
	const NOOP_TRACER = new NoopTracer_1$1.NoopTracer();
	/**
	 * Proxy tracer provided by the proxy tracer provider
	 */
	class ProxyTracer {
	    constructor(_provider, name, version, options) {
	        this._provider = _provider;
	        this.name = name;
	        this.version = version;
	        this.options = options;
	    }
	    startSpan(name, options, context) {
	        return this._getTracer().startSpan(name, options, context);
	    }
	    startActiveSpan(_name, _options, _context, _fn) {
	        const tracer = this._getTracer();
	        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
	    }
	    /**
	     * Try to get a tracer from the proxy tracer provider.
	     * If the proxy tracer provider has no delegate, return a noop tracer.
	     */
	    _getTracer() {
	        if (this._delegate) {
	            return this._delegate;
	        }
	        const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
	        if (!tracer) {
	            return NOOP_TRACER;
	        }
	        this._delegate = tracer;
	        return this._delegate;
	    }
	}
	ProxyTracer$1.ProxyTracer = ProxyTracer;

	var ProxyTracerProvider$1 = {};

	var NoopTracerProvider$1 = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NoopTracerProvider$1, "__esModule", { value: true });
	NoopTracerProvider$1.NoopTracerProvider = void 0;
	const NoopTracer_1 = NoopTracer$1;
	/**
	 * An implementation of the {@link TracerProvider} which returns an impotent
	 * Tracer for all calls to `getTracer`.
	 *
	 * All operations are no-op.
	 */
	class NoopTracerProvider {
	    getTracer(_name, _version, _options) {
	        return new NoopTracer_1.NoopTracer();
	    }
	}
	NoopTracerProvider$1.NoopTracerProvider = NoopTracerProvider;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(ProxyTracerProvider$1, "__esModule", { value: true });
	ProxyTracerProvider$1.ProxyTracerProvider = void 0;
	const ProxyTracer_1 = ProxyTracer$1;
	const NoopTracerProvider_1 = NoopTracerProvider$1;
	const NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider();
	/**
	 * Tracer provider which provides {@link ProxyTracer}s.
	 *
	 * Before a delegate is set, tracers provided are NoOp.
	 *   When a delegate is set, traces are provided from the delegate.
	 *   When a delegate is set after tracers have already been provided,
	 *   all tracers already provided will use the provided delegate implementation.
	 */
	class ProxyTracerProvider {
	    /**
	     * Get a {@link ProxyTracer}
	     */
	    getTracer(name, version, options) {
	        var _a;
	        return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options));
	    }
	    getDelegate() {
	        var _a;
	        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
	    }
	    /**
	     * Set the delegate tracer provider
	     */
	    setDelegate(delegate) {
	        this._delegate = delegate;
	    }
	    getDelegateTracer(name, version, options) {
	        var _a;
	        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
	    }
	}
	ProxyTracerProvider$1.ProxyTracerProvider = ProxyTracerProvider;

	var SamplingResult = {};

	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SamplingDecision = void 0;
		(function (SamplingDecision) {
		    /**
		     * `Span.isRecording() === false`, span will not be recorded and all events
		     * and attributes will be dropped.
		     */
		    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
		    /**
		     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
		     * MUST NOT be set.
		     */
		    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
		    /**
		     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
		     * MUST be set.
		     */
		    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
		})(exports.SamplingDecision || (exports.SamplingDecision = {}));
		
	} (SamplingResult));

	var span_kind = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SpanKind = void 0;
		(function (SpanKind) {
		    /** Default value. Indicates that the span is used internally. */
		    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
		    /**
		     * Indicates that the span covers server-side handling of an RPC or other
		     * remote request.
		     */
		    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
		    /**
		     * Indicates that the span covers the client-side wrapper around an RPC or
		     * other remote request.
		     */
		    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
		    /**
		     * Indicates that the span describes producer sending a message to a
		     * broker. Unlike client and server, there is no direct critical path latency
		     * relationship between producer and consumer spans.
		     */
		    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
		    /**
		     * Indicates that the span describes consumer receiving a message from a
		     * broker. Unlike client and server, there is no direct critical path latency
		     * relationship between producer and consumer spans.
		     */
		    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
		})(exports.SpanKind || (exports.SpanKind = {}));
		
	} (span_kind));

	var status = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SpanStatusCode = void 0;
		(function (SpanStatusCode) {
		    /**
		     * The default status.
		     */
		    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
		    /**
		     * The operation has been validated by an Application developer or
		     * Operator to have completed successfully.
		     */
		    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
		    /**
		     * The operation contains an error.
		     */
		    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
		})(exports.SpanStatusCode || (exports.SpanStatusCode = {}));
		
	} (status));

	var utils = {};

	var tracestateImpl = {};

	var tracestateValidators = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(tracestateValidators, "__esModule", { value: true });
	tracestateValidators.validateValue = tracestateValidators.validateKey = void 0;
	const VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
	const VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
	const VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
	const VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
	const VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
	const INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
	/**
	 * Key is opaque string up to 256 characters printable. It MUST begin with a
	 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
	 * underscores _, dashes -, asterisks *, and forward slashes /.
	 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
	 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
	 * see https://www.w3.org/TR/trace-context/#key
	 */
	function validateKey(key) {
	    return VALID_KEY_REGEX.test(key);
	}
	tracestateValidators.validateKey = validateKey;
	/**
	 * Value is opaque string up to 256 characters printable ASCII RFC0020
	 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
	 */
	function validateValue(value) {
	    return (VALID_VALUE_BASE_REGEX.test(value) &&
	        !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
	}
	tracestateValidators.validateValue = validateValue;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(tracestateImpl, "__esModule", { value: true });
	tracestateImpl.TraceStateImpl = void 0;
	const tracestate_validators_1 = tracestateValidators;
	const MAX_TRACE_STATE_ITEMS = 32;
	const MAX_TRACE_STATE_LEN = 512;
	const LIST_MEMBERS_SEPARATOR = ',';
	const LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
	/**
	 * TraceState must be a class and not a simple object type because of the spec
	 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
	 *
	 * Here is the list of allowed mutations:
	 * - New key-value pair should be added into the beginning of the list
	 * - The value of any key can be updated. Modified keys MUST be moved to the
	 * beginning of the list.
	 */
	class TraceStateImpl {
	    constructor(rawTraceState) {
	        this._internalState = new Map();
	        if (rawTraceState)
	            this._parse(rawTraceState);
	    }
	    set(key, value) {
	        // TODO: Benchmark the different approaches(map vs list) and
	        // use the faster one.
	        const traceState = this._clone();
	        if (traceState._internalState.has(key)) {
	            traceState._internalState.delete(key);
	        }
	        traceState._internalState.set(key, value);
	        return traceState;
	    }
	    unset(key) {
	        const traceState = this._clone();
	        traceState._internalState.delete(key);
	        return traceState;
	    }
	    get(key) {
	        return this._internalState.get(key);
	    }
	    serialize() {
	        return this._keys()
	            .reduce((agg, key) => {
	            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
	            return agg;
	        }, [])
	            .join(LIST_MEMBERS_SEPARATOR);
	    }
	    _parse(rawTraceState) {
	        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
	            return;
	        this._internalState = rawTraceState
	            .split(LIST_MEMBERS_SEPARATOR)
	            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
	            .reduce((agg, part) => {
	            const listMember = part.trim(); // Optional Whitespace (OWS) handling
	            const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
	            if (i !== -1) {
	                const key = listMember.slice(0, i);
	                const value = listMember.slice(i + 1, part.length);
	                if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
	                    agg.set(key, value);
	                }
	            }
	            return agg;
	        }, new Map());
	        // Because of the reverse() requirement, trunc must be done after map is created
	        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
	            this._internalState = new Map(Array.from(this._internalState.entries())
	                .reverse() // Use reverse same as original tracestate parse chain
	                .slice(0, MAX_TRACE_STATE_ITEMS));
	        }
	    }
	    _keys() {
	        return Array.from(this._internalState.keys()).reverse();
	    }
	    _clone() {
	        const traceState = new TraceStateImpl();
	        traceState._internalState = new Map(this._internalState);
	        return traceState;
	    }
	}
	tracestateImpl.TraceStateImpl = TraceStateImpl;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(utils, "__esModule", { value: true });
	utils.createTraceState = void 0;
	const tracestate_impl_1 = tracestateImpl;
	function createTraceState(rawTraceState) {
	    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
	}
	utils.createTraceState = createTraceState;

	var contextApi = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(contextApi, "__esModule", { value: true });
	contextApi.context = void 0;
	// Split module-level variable definition into separate files to allow
	// tree-shaking on each api instance.
	const context_1$1 = context;
	/** Entrypoint for context API */
	contextApi.context = context_1$1.ContextAPI.getInstance();

	var diagApi = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(diagApi, "__esModule", { value: true });
	diagApi.diag = void 0;
	// Split module-level variable definition into separate files to allow
	// tree-shaking on each api instance.
	const diag_1$3 = diag$1;
	/**
	 * Entrypoint for Diag API.
	 * Defines Diagnostic handler used for internal diagnostic logging operations.
	 * The default provides a Noop DiagLogger implementation which may be changed via the
	 * diag.setLogger(logger: DiagLogger) function.
	 */
	diagApi.diag = diag_1$3.DiagAPI.instance();

	var metricsApi = {};

	var metrics = {};

	var NoopMeterProvider$1 = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NoopMeterProvider$1, "__esModule", { value: true });
	NoopMeterProvider$1.NOOP_METER_PROVIDER = NoopMeterProvider$1.NoopMeterProvider = void 0;
	const NoopMeter_1 = NoopMeter;
	/**
	 * An implementation of the {@link MeterProvider} which returns an impotent Meter
	 * for all calls to `getMeter`
	 */
	class NoopMeterProvider {
	    getMeter(_name, _version, _options) {
	        return NoopMeter_1.NOOP_METER;
	    }
	}
	NoopMeterProvider$1.NoopMeterProvider = NoopMeterProvider;
	NoopMeterProvider$1.NOOP_METER_PROVIDER = new NoopMeterProvider();

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(metrics, "__esModule", { value: true });
	metrics.MetricsAPI = void 0;
	const NoopMeterProvider_1 = NoopMeterProvider$1;
	const global_utils_1$2 = globalUtils;
	const diag_1$2 = diag$1;
	const API_NAME$2 = 'metrics';
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
	 */
	class MetricsAPI {
	    /** Empty private constructor prevents end users from constructing a new instance of the API */
	    constructor() { }
	    /** Get the singleton instance of the Metrics API */
	    static getInstance() {
	        if (!this._instance) {
	            this._instance = new MetricsAPI();
	        }
	        return this._instance;
	    }
	    /**
	     * Set the current global meter provider.
	     * Returns true if the meter provider was successfully registered, else false.
	     */
	    setGlobalMeterProvider(provider) {
	        return (0, global_utils_1$2.registerGlobal)(API_NAME$2, provider, diag_1$2.DiagAPI.instance());
	    }
	    /**
	     * Returns the global meter provider.
	     */
	    getMeterProvider() {
	        return (0, global_utils_1$2.getGlobal)(API_NAME$2) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
	    }
	    /**
	     * Returns a meter from the global meter provider.
	     */
	    getMeter(name, version, options) {
	        return this.getMeterProvider().getMeter(name, version, options);
	    }
	    /** Remove the global meter provider */
	    disable() {
	        (0, global_utils_1$2.unregisterGlobal)(API_NAME$2, diag_1$2.DiagAPI.instance());
	    }
	}
	metrics.MetricsAPI = MetricsAPI;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(metricsApi, "__esModule", { value: true });
	metricsApi.metrics = void 0;
	// Split module-level variable definition into separate files to allow
	// tree-shaking on each api instance.
	const metrics_1 = metrics;
	/** Entrypoint for metrics API */
	metricsApi.metrics = metrics_1.MetricsAPI.getInstance();

	var propagationApi = {};

	var propagation = {};

	var NoopTextMapPropagator$1 = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NoopTextMapPropagator$1, "__esModule", { value: true });
	NoopTextMapPropagator$1.NoopTextMapPropagator = void 0;
	/**
	 * No-op implementations of {@link TextMapPropagator}.
	 */
	class NoopTextMapPropagator {
	    /** Noop inject function does nothing */
	    inject(_context, _carrier) { }
	    /** Noop extract function does nothing and returns the input context */
	    extract(context, _carrier) {
	        return context;
	    }
	    fields() {
	        return [];
	    }
	}
	NoopTextMapPropagator$1.NoopTextMapPropagator = NoopTextMapPropagator;

	var contextHelpers = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(contextHelpers, "__esModule", { value: true });
	contextHelpers.deleteBaggage = contextHelpers.setBaggage = contextHelpers.getActiveBaggage = contextHelpers.getBaggage = void 0;
	const context_1 = context;
	const context_2 = context$1;
	/**
	 * Baggage key
	 */
	const BAGGAGE_KEY = (0, context_2.createContextKey)('OpenTelemetry Baggage Key');
	/**
	 * Retrieve the current baggage from the given context
	 *
	 * @param {Context} Context that manage all context values
	 * @returns {Baggage} Extracted baggage from the context
	 */
	function getBaggage(context) {
	    return context.getValue(BAGGAGE_KEY) || undefined;
	}
	contextHelpers.getBaggage = getBaggage;
	/**
	 * Retrieve the current baggage from the active/current context
	 *
	 * @returns {Baggage} Extracted baggage from the context
	 */
	function getActiveBaggage() {
	    return getBaggage(context_1.ContextAPI.getInstance().active());
	}
	contextHelpers.getActiveBaggage = getActiveBaggage;
	/**
	 * Store a baggage in the given context
	 *
	 * @param {Context} Context that manage all context values
	 * @param {Baggage} baggage that will be set in the actual context
	 */
	function setBaggage(context, baggage) {
	    return context.setValue(BAGGAGE_KEY, baggage);
	}
	contextHelpers.setBaggage = setBaggage;
	/**
	 * Delete the baggage stored in the given context
	 *
	 * @param {Context} Context that manage all context values
	 */
	function deleteBaggage(context) {
	    return context.deleteValue(BAGGAGE_KEY);
	}
	contextHelpers.deleteBaggage = deleteBaggage;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(propagation, "__esModule", { value: true });
	propagation.PropagationAPI = void 0;
	const global_utils_1$1 = globalUtils;
	const NoopTextMapPropagator_1 = NoopTextMapPropagator$1;
	const TextMapPropagator_1 = TextMapPropagator;
	const context_helpers_1 = contextHelpers;
	const utils_1 = utils$1;
	const diag_1$1 = diag$1;
	const API_NAME$1 = 'propagation';
	const NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator();
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
	 */
	class PropagationAPI {
	    /** Empty private constructor prevents end users from constructing a new instance of the API */
	    constructor() {
	        this.createBaggage = utils_1.createBaggage;
	        this.getBaggage = context_helpers_1.getBaggage;
	        this.getActiveBaggage = context_helpers_1.getActiveBaggage;
	        this.setBaggage = context_helpers_1.setBaggage;
	        this.deleteBaggage = context_helpers_1.deleteBaggage;
	    }
	    /** Get the singleton instance of the Propagator API */
	    static getInstance() {
	        if (!this._instance) {
	            this._instance = new PropagationAPI();
	        }
	        return this._instance;
	    }
	    /**
	     * Set the current propagator.
	     *
	     * @returns true if the propagator was successfully registered, else false
	     */
	    setGlobalPropagator(propagator) {
	        return (0, global_utils_1$1.registerGlobal)(API_NAME$1, propagator, diag_1$1.DiagAPI.instance());
	    }
	    /**
	     * Inject context into a carrier to be propagated inter-process
	     *
	     * @param context Context carrying tracing data to inject
	     * @param carrier carrier to inject context into
	     * @param setter Function used to set values on the carrier
	     */
	    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
	        return this._getGlobalPropagator().inject(context, carrier, setter);
	    }
	    /**
	     * Extract context from a carrier
	     *
	     * @param context Context which the newly created context will inherit from
	     * @param carrier Carrier to extract context from
	     * @param getter Function used to extract keys from a carrier
	     */
	    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
	        return this._getGlobalPropagator().extract(context, carrier, getter);
	    }
	    /**
	     * Return a list of all fields which may be used by the propagator.
	     */
	    fields() {
	        return this._getGlobalPropagator().fields();
	    }
	    /** Remove the global propagator */
	    disable() {
	        (0, global_utils_1$1.unregisterGlobal)(API_NAME$1, diag_1$1.DiagAPI.instance());
	    }
	    _getGlobalPropagator() {
	        return (0, global_utils_1$1.getGlobal)(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
	    }
	}
	propagation.PropagationAPI = PropagationAPI;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(propagationApi, "__esModule", { value: true });
	propagationApi.propagation = void 0;
	// Split module-level variable definition into separate files to allow
	// tree-shaking on each api instance.
	const propagation_1 = propagation;
	/** Entrypoint for propagation API */
	propagationApi.propagation = propagation_1.PropagationAPI.getInstance();

	var traceApi = {};

	var trace = {};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(trace, "__esModule", { value: true });
	trace.TraceAPI = void 0;
	const global_utils_1 = globalUtils;
	const ProxyTracerProvider_1 = ProxyTracerProvider$1;
	const spancontext_utils_1 = spancontextUtils;
	const context_utils_1 = contextUtils;
	const diag_1 = diag$1;
	const API_NAME = 'trace';
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
	 */
	class TraceAPI {
	    /** Empty private constructor prevents end users from constructing a new instance of the API */
	    constructor() {
	        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
	        this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
	        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
	        this.deleteSpan = context_utils_1.deleteSpan;
	        this.getSpan = context_utils_1.getSpan;
	        this.getActiveSpan = context_utils_1.getActiveSpan;
	        this.getSpanContext = context_utils_1.getSpanContext;
	        this.setSpan = context_utils_1.setSpan;
	        this.setSpanContext = context_utils_1.setSpanContext;
	    }
	    /** Get the singleton instance of the Trace API */
	    static getInstance() {
	        if (!this._instance) {
	            this._instance = new TraceAPI();
	        }
	        return this._instance;
	    }
	    /**
	     * Set the current global tracer.
	     *
	     * @returns true if the tracer provider was successfully registered, else false
	     */
	    setGlobalTracerProvider(provider) {
	        const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
	        if (success) {
	            this._proxyTracerProvider.setDelegate(provider);
	        }
	        return success;
	    }
	    /**
	     * Returns the global tracer provider.
	     */
	    getTracerProvider() {
	        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
	    }
	    /**
	     * Returns a tracer from the global tracer provider.
	     */
	    getTracer(name, version) {
	        return this.getTracerProvider().getTracer(name, version);
	    }
	    /** Remove the global tracer provider */
	    disable() {
	        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
	        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
	    }
	}
	trace.TraceAPI = TraceAPI;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(traceApi, "__esModule", { value: true });
	traceApi.trace = void 0;
	// Split module-level variable definition into separate files to allow
	// tree-shaking on each api instance.
	const trace_1 = trace;
	/** Entrypoint for trace API */
	traceApi.trace = trace_1.TraceAPI.getInstance();

	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = void 0;
		var utils_1 = utils$1;
		Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function () { return utils_1.baggageEntryMetadataFromString; } });
		// Context APIs
		var context_1 = context$1;
		Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function () { return context_1.createContextKey; } });
		Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function () { return context_1.ROOT_CONTEXT; } });
		// Diag APIs
		var consoleLogger_1 = consoleLogger;
		Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function () { return consoleLogger_1.DiagConsoleLogger; } });
		var types_1 = types;
		Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function () { return types_1.DiagLogLevel; } });
		// Metrics APIs
		var NoopMeter_1 = NoopMeter;
		Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function () { return NoopMeter_1.createNoopMeter; } });
		var Metric_1 = Metric;
		Object.defineProperty(exports, "ValueType", { enumerable: true, get: function () { return Metric_1.ValueType; } });
		// Propagation APIs
		var TextMapPropagator_1 = TextMapPropagator;
		Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function () { return TextMapPropagator_1.defaultTextMapGetter; } });
		Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function () { return TextMapPropagator_1.defaultTextMapSetter; } });
		var ProxyTracer_1 = ProxyTracer$1;
		Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function () { return ProxyTracer_1.ProxyTracer; } });
		var ProxyTracerProvider_1 = ProxyTracerProvider$1;
		Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function () { return ProxyTracerProvider_1.ProxyTracerProvider; } });
		var SamplingResult_1 = SamplingResult;
		Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function () { return SamplingResult_1.SamplingDecision; } });
		var span_kind_1 = span_kind;
		Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function () { return span_kind_1.SpanKind; } });
		var status_1 = status;
		Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function () { return status_1.SpanStatusCode; } });
		var trace_flags_1 = trace_flags;
		Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function () { return trace_flags_1.TraceFlags; } });
		var utils_2 = utils;
		Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function () { return utils_2.createTraceState; } });
		var spancontext_utils_1 = spancontextUtils;
		Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function () { return spancontext_utils_1.isSpanContextValid; } });
		Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function () { return spancontext_utils_1.isValidTraceId; } });
		Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function () { return spancontext_utils_1.isValidSpanId; } });
		var invalid_span_constants_1 = invalidSpanConstants;
		Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function () { return invalid_span_constants_1.INVALID_SPANID; } });
		Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function () { return invalid_span_constants_1.INVALID_TRACEID; } });
		Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function () { return invalid_span_constants_1.INVALID_SPAN_CONTEXT; } });
		// Split module-level variable definition into separate files to allow
		// tree-shaking on each api instance.
		const context_api_1 = contextApi;
		Object.defineProperty(exports, "context", { enumerable: true, get: function () { return context_api_1.context; } });
		const diag_api_1 = diagApi;
		Object.defineProperty(exports, "diag", { enumerable: true, get: function () { return diag_api_1.diag; } });
		const metrics_api_1 = metricsApi;
		Object.defineProperty(exports, "metrics", { enumerable: true, get: function () { return metrics_api_1.metrics; } });
		const propagation_api_1 = propagationApi;
		Object.defineProperty(exports, "propagation", { enumerable: true, get: function () { return propagation_api_1.propagation; } });
		const trace_api_1 = traceApi;
		Object.defineProperty(exports, "trace", { enumerable: true, get: function () { return trace_api_1.trace; } });
		// Default export.
		exports.default = {
		    context: context_api_1.context,
		    diag: diag_api_1.diag,
		    metrics: metrics_api_1.metrics,
		    propagation: propagation_api_1.propagation,
		    trace: trace_api_1.trace,
		};
		
	} (src));

	exports.commonjsGlobal = commonjsGlobal;
	exports.src = src;

}));
