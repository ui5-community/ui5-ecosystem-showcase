sap.ui.define(['exports'], (function (exports) { 'use strict';

  var global$1 = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Updates to this file should also be replicated to @opentelemetry/core too.
  /**
   * - globalThis (New standard)
   * - self (Will return the current window instance for supported browsers)
   * - window (fallback for older browser implementations)
   * - global (NodeJS implementation)
   * - <object> (When all else fails)
   */
  /** only globals that common to node and browsers are allowed */
  // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
  const _globalThis = typeof globalThis === 'object'
      ? globalThis
      : typeof self === 'object'
          ? self
          : typeof window === 'object'
              ? window
              : typeof global$1 === 'object'
                  ? global$1
                  : {};

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // this is autogenerated file, see scripts/version-update.js
  const VERSION = '1.9.0';

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  /**
   * Create a function to test an API version to see if it is compatible with the provided ownVersion.
   *
   * The returned function has the following semantics:
   * - Exact match is always compatible
   * - Major versions must match exactly
   *    - 1.x package cannot use global 2.x package
   *    - 2.x package cannot use global 1.x package
   * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
   *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
   *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
   * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
   * - Patch and build tag differences are not considered at this time
   *
   * @param ownVersion version which should be checked against
   */
  function _makeCompatibilityCheck(ownVersion) {
      const acceptedVersions = new Set([ownVersion]);
      const rejectedVersions = new Set();
      const myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
          // we cannot guarantee compatibility so we always return noop
          return () => false;
      }
      const ownVersionParsed = {
          major: +myVersionMatch[1],
          minor: +myVersionMatch[2],
          patch: +myVersionMatch[3],
          prerelease: myVersionMatch[4],
      };
      // if ownVersion has a prerelease tag, versions must match exactly
      if (ownVersionParsed.prerelease != null) {
          return function isExactmatch(globalVersion) {
              return globalVersion === ownVersion;
          };
      }
      function _reject(v) {
          rejectedVersions.add(v);
          return false;
      }
      function _accept(v) {
          acceptedVersions.add(v);
          return true;
      }
      return function isCompatible(globalVersion) {
          if (acceptedVersions.has(globalVersion)) {
              return true;
          }
          if (rejectedVersions.has(globalVersion)) {
              return false;
          }
          const globalVersionMatch = globalVersion.match(re);
          if (!globalVersionMatch) {
              // cannot parse other version
              // we cannot guarantee compatibility so we always noop
              return _reject(globalVersion);
          }
          const globalVersionParsed = {
              major: +globalVersionMatch[1],
              minor: +globalVersionMatch[2],
              patch: +globalVersionMatch[3],
              prerelease: globalVersionMatch[4],
          };
          // if globalVersion has a prerelease tag, versions must match exactly
          if (globalVersionParsed.prerelease != null) {
              return _reject(globalVersion);
          }
          // major versions must match
          if (ownVersionParsed.major !== globalVersionParsed.major) {
              return _reject(globalVersion);
          }
          if (ownVersionParsed.major === 0) {
              if (ownVersionParsed.minor === globalVersionParsed.minor &&
                  ownVersionParsed.patch <= globalVersionParsed.patch) {
                  return _accept(globalVersion);
              }
              return _reject(globalVersion);
          }
          if (ownVersionParsed.minor <= globalVersionParsed.minor) {
              return _accept(globalVersion);
          }
          return _reject(globalVersion);
      };
  }
  /**
   * Test an API version to see if it is compatible with this API.
   *
   * - Exact match is always compatible
   * - Major versions must match exactly
   *    - 1.x package cannot use global 2.x package
   *    - 2.x package cannot use global 1.x package
   * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
   *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
   *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
   * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
   * - Patch and build tag differences are not considered at this time
   *
   * @param version version of the API requesting an instance of the global API
   */
  const isCompatible = _makeCompatibilityCheck(VERSION);

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const major = VERSION.split('.')[0];
  const GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  const _global = _globalThis;
  function registerGlobal(type, instance, diag, allowOverride = false) {
      var _a;
      const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
          version: VERSION,
      });
      if (!allowOverride && api[type]) {
          // already registered an API of this type
          const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
          diag.error(err.stack || err.message);
          return false;
      }
      if (api.version !== VERSION) {
          // All registered APIs must be of the same version exactly
          const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`);
          diag.error(err.stack || err.message);
          return false;
      }
      api[type] = instance;
      diag.debug(`@opentelemetry/api: Registered a global for ${type} v${VERSION}.`);
      return true;
  }
  function getGlobal(type) {
      var _a, _b;
      const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
      if (!globalVersion || !isCompatible(globalVersion)) {
          return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
  }
  function unregisterGlobal(type, diag) {
      diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`);
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
          delete api[type];
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Component Logger which is meant to be used as part of any component which
   * will add automatically additional namespace in front of the log message.
   * It will then forward all message to global diag logger
   * @example
   * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
   * cLogger.debug('test');
   * // @opentelemetry/instrumentation-http test
   */
  class DiagComponentLogger {
      constructor(props) {
          this._namespace = props.namespace || 'DiagComponentLogger';
      }
      debug(...args) {
          return logProxy('debug', this._namespace, args);
      }
      error(...args) {
          return logProxy('error', this._namespace, args);
      }
      info(...args) {
          return logProxy('info', this._namespace, args);
      }
      warn(...args) {
          return logProxy('warn', this._namespace, args);
      }
      verbose(...args) {
          return logProxy('verbose', this._namespace, args);
      }
  }
  function logProxy(funcName, namespace, args) {
      const logger = getGlobal('diag');
      // shortcut if logger not set
      if (!logger) {
          return;
      }
      args.unshift(namespace);
      return logger[funcName](...args);
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Defines the available internal logging levels for the diagnostic logger, the numeric values
   * of the levels are defined to match the original values from the initial LogLevel to avoid
   * compatibility/migration issues for any implementation that assume the numeric ordering.
   */
  exports.DiagLogLevel = void 0;
  (function (DiagLogLevel) {
      /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
      DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
      /** Identifies an error scenario */
      DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
      /** Identifies a warning scenario */
      DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
      /** General informational log message */
      DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
      /** General debug log message */
      DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
      /**
       * Detailed trace level logging should only be used for development, should only be set
       * in a development environment.
       */
      DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
      /** Used to set the logging level to include all logging */
      DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
  })(exports.DiagLogLevel || (exports.DiagLogLevel = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function createLogLevelDiagLogger(maxLevel, logger) {
      if (maxLevel < exports.DiagLogLevel.NONE) {
          maxLevel = exports.DiagLogLevel.NONE;
      }
      else if (maxLevel > exports.DiagLogLevel.ALL) {
          maxLevel = exports.DiagLogLevel.ALL;
      }
      // In case the logger is null or undefined
      logger = logger || {};
      function _filterFunc(funcName, theLevel) {
          const theFunc = logger[funcName];
          if (typeof theFunc === 'function' && maxLevel >= theLevel) {
              return theFunc.bind(logger);
          }
          return function () { };
      }
      return {
          error: _filterFunc('error', exports.DiagLogLevel.ERROR),
          warn: _filterFunc('warn', exports.DiagLogLevel.WARN),
          info: _filterFunc('info', exports.DiagLogLevel.INFO),
          debug: _filterFunc('debug', exports.DiagLogLevel.DEBUG),
          verbose: _filterFunc('verbose', exports.DiagLogLevel.VERBOSE),
      };
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const API_NAME$4 = 'diag';
  /**
   * Singleton object which represents the entry point to the OpenTelemetry internal
   * diagnostic API
   */
  class DiagAPI {
      /**
       * Private internal constructor
       * @private
       */
      constructor() {
          function _logProxy(funcName) {
              return function (...args) {
                  const logger = getGlobal('diag');
                  // shortcut if logger not set
                  if (!logger)
                      return;
                  return logger[funcName](...args);
              };
          }
          // Using self local variable for minification purposes as 'this' cannot be minified
          const self = this;
          // DiagAPI specific functions
          const setLogger = (logger, optionsOrLogLevel = { logLevel: exports.DiagLogLevel.INFO }) => {
              var _a, _b, _c;
              if (logger === self) {
                  // There isn't much we can do here.
                  // Logging to the console might break the user application.
                  // Try to log to self. If a logger was previously registered it will receive the log.
                  const err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                  self.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
                  return false;
              }
              if (typeof optionsOrLogLevel === 'number') {
                  optionsOrLogLevel = {
                      logLevel: optionsOrLogLevel,
                  };
              }
              const oldLogger = getGlobal('diag');
              const newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : exports.DiagLogLevel.INFO, logger);
              // There already is an logger registered. We'll let it know before overwriting it.
              if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                  const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : '<failed to generate stacktrace>';
                  oldLogger.warn(`Current logger will be overwritten from ${stack}`);
                  newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
              }
              return registerGlobal('diag', newLogger, self, true);
          };
          self.setLogger = setLogger;
          self.disable = () => {
              unregisterGlobal(API_NAME$4, self);
          };
          self.createComponentLogger = (options) => {
              return new DiagComponentLogger(options);
          };
          self.verbose = _logProxy('verbose');
          self.debug = _logProxy('debug');
          self.info = _logProxy('info');
          self.warn = _logProxy('warn');
          self.error = _logProxy('error');
      }
      /** Get the singleton instance of the DiagAPI API */
      static instance() {
          if (!this._instance) {
              this._instance = new DiagAPI();
          }
          return this._instance;
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class BaggageImpl {
      constructor(entries) {
          this._entries = entries ? new Map(entries) : new Map();
      }
      getEntry(key) {
          const entry = this._entries.get(key);
          if (!entry) {
              return undefined;
          }
          return Object.assign({}, entry);
      }
      getAllEntries() {
          return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
      }
      setEntry(key, entry) {
          const newBaggage = new BaggageImpl(this._entries);
          newBaggage._entries.set(key, entry);
          return newBaggage;
      }
      removeEntry(key) {
          const newBaggage = new BaggageImpl(this._entries);
          newBaggage._entries.delete(key);
          return newBaggage;
      }
      removeEntries(...keys) {
          const newBaggage = new BaggageImpl(this._entries);
          for (const key of keys) {
              newBaggage._entries.delete(key);
          }
          return newBaggage;
      }
      clear() {
          return new BaggageImpl();
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Symbol used to make BaggageEntryMetadata an opaque type
   */
  const baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const diag$1 = DiagAPI.instance();
  /**
   * Create a new Baggage with optional entries
   *
   * @param entries An array of baggage entries the new baggage should contain
   */
  function createBaggage(entries = {}) {
      return new BaggageImpl(new Map(Object.entries(entries)));
  }
  /**
   * Create a serializable BaggageEntryMetadata object from a string.
   *
   * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
   *
   */
  function baggageEntryMetadataFromString(str) {
      if (typeof str !== 'string') {
          diag$1.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
          str = '';
      }
      return {
          __TYPE__: baggageEntryMetadataSymbol,
          toString() {
              return str;
          },
      };
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /** Get a key to uniquely identify a context value */
  function createContextKey(description) {
      // The specification states that for the same input, multiple calls should
      // return different keys. Due to the nature of the JS dependency management
      // system, this creates problems where multiple versions of some package
      // could hold different keys for the same property.
      //
      // Therefore, we use Symbol.for which returns the same key for the same input.
      return Symbol.for(description);
  }
  class BaseContext {
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      constructor(parentContext) {
          // for minification
          const self = this;
          self._currentContext = parentContext ? new Map(parentContext) : new Map();
          self.getValue = (key) => self._currentContext.get(key);
          self.setValue = (key, value) => {
              const context = new BaseContext(self._currentContext);
              context._currentContext.set(key, value);
              return context;
          };
          self.deleteValue = (key) => {
              const context = new BaseContext(self._currentContext);
              context._currentContext.delete(key);
              return context;
          };
      }
  }
  /** The root context is used as the default parent context when there is no active context */
  const ROOT_CONTEXT = new BaseContext();

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
   * constant NoopMetrics for all of its methods.
   */
  class NoopMeter {
      constructor() { }
      /**
       * @see {@link Meter.createGauge}
       */
      createGauge(_name, _options) {
          return NOOP_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createHistogram}
       */
      createHistogram(_name, _options) {
          return NOOP_HISTOGRAM_METRIC;
      }
      /**
       * @see {@link Meter.createCounter}
       */
      createCounter(_name, _options) {
          return NOOP_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      createUpDownCounter(_name, _options) {
          return NOOP_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableGauge}
       */
      createObservableGauge(_name, _options) {
          return NOOP_OBSERVABLE_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createObservableCounter}
       */
      createObservableCounter(_name, _options) {
          return NOOP_OBSERVABLE_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      createObservableUpDownCounter(_name, _options) {
          return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(_callback, _observables) { }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(_callback) { }
  }
  class NoopMetric {
  }
  class NoopCounterMetric extends NoopMetric {
      add(_value, _attributes) { }
  }
  class NoopUpDownCounterMetric extends NoopMetric {
      add(_value, _attributes) { }
  }
  class NoopGaugeMetric extends NoopMetric {
      record(_value, _attributes) { }
  }
  class NoopHistogramMetric extends NoopMetric {
      record(_value, _attributes) { }
  }
  class NoopObservableMetric {
      addCallback(_callback) { }
      removeCallback(_callback) { }
  }
  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  const NOOP_METER = new NoopMeter();
  // Synchronous instruments
  const NOOP_COUNTER_METRIC = new NoopCounterMetric();
  const NOOP_GAUGE_METRIC = new NoopGaugeMetric();
  const NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
  const NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
  // Asynchronous instruments
  const NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
  const NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
  const NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  /**
   * Create a no-op Meter
   */
  function createNoopMeter() {
      return NOOP_METER;
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /** The Type of value. It describes how the data is reported. */
  exports.ValueType = void 0;
  (function (ValueType) {
      ValueType[ValueType["INT"] = 0] = "INT";
      ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
  })(exports.ValueType || (exports.ValueType = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const defaultTextMapGetter = {
      get(carrier, key) {
          if (carrier == null) {
              return undefined;
          }
          return carrier[key];
      },
      keys(carrier) {
          if (carrier == null) {
              return [];
          }
          return Object.keys(carrier);
      },
  };
  const defaultTextMapSetter = {
      set(carrier, key, value) {
          if (carrier == null) {
              return;
          }
          carrier[key] = value;
      },
  };

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class NoopContextManager {
      active() {
          return ROOT_CONTEXT;
      }
      with(_context, fn, thisArg, ...args) {
          return fn.call(thisArg, ...args);
      }
      bind(_context, target) {
          return target;
      }
      enable() {
          return this;
      }
      disable() {
          return this;
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const API_NAME$3 = 'context';
  const NOOP_CONTEXT_MANAGER = new NoopContextManager();
  /**
   * Singleton object which represents the entry point to the OpenTelemetry Context API
   */
  class ContextAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() { }
      /** Get the singleton instance of the Context API */
      static getInstance() {
          if (!this._instance) {
              this._instance = new ContextAPI();
          }
          return this._instance;
      }
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      setGlobalContextManager(contextManager) {
          return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
      }
      /**
       * Get the currently active context
       */
      active() {
          return this._getContextManager().active();
      }
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      with(context, fn, thisArg, ...args) {
          return this._getContextManager().with(context, fn, thisArg, ...args);
      }
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      bind(context, target) {
          return this._getContextManager().bind(context, target);
      }
      _getContextManager() {
          return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
      }
      /** Disable and remove the global context manager */
      disable() {
          this._getContextManager().disable();
          unregisterGlobal(API_NAME$3, DiagAPI.instance());
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  exports.TraceFlags = void 0;
  (function (TraceFlags) {
      /** Represents no flag set. */
      TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
      /** Bit to represent whether trace is sampled in trace flags. */
      TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
  })(exports.TraceFlags || (exports.TraceFlags = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const INVALID_SPANID = '0000000000000000';
  const INVALID_TRACEID = '00000000000000000000000000000000';
  const INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: exports.TraceFlags.NONE,
  };

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * The NonRecordingSpan is the default {@link Span} that is used when no Span
   * implementation is available. All operations are no-op including context
   * propagation.
   */
  class NonRecordingSpan {
      constructor(_spanContext = INVALID_SPAN_CONTEXT) {
          this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      spanContext() {
          return this._spanContext;
      }
      // By default does nothing
      setAttribute(_key, _value) {
          return this;
      }
      // By default does nothing
      setAttributes(_attributes) {
          return this;
      }
      // By default does nothing
      addEvent(_name, _attributes) {
          return this;
      }
      addLink(_link) {
          return this;
      }
      addLinks(_links) {
          return this;
      }
      // By default does nothing
      setStatus(_status) {
          return this;
      }
      // By default does nothing
      updateName(_name) {
          return this;
      }
      // By default does nothing
      end(_endTime) { }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
          return false;
      }
      // By default does nothing
      recordException(_exception, _time) { }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * span key
   */
  const SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
  /**
   * Return the span if one exists
   *
   * @param context context to get span from
   */
  function getSpan(context) {
      return context.getValue(SPAN_KEY) || undefined;
  }
  /**
   * Gets the span from the current context, if one exists.
   */
  function getActiveSpan() {
      return getSpan(ContextAPI.getInstance().active());
  }
  /**
   * Set the span on a context
   *
   * @param context context to use as parent
   * @param span span to set active
   */
  function setSpan(context, span) {
      return context.setValue(SPAN_KEY, span);
  }
  /**
   * Remove current span stored in the context
   *
   * @param context context to delete span from
   */
  function deleteSpan(context) {
      return context.deleteValue(SPAN_KEY);
  }
  /**
   * Wrap span context in a NoopSpan and set as span in a new
   * context
   *
   * @param context context to set active span on
   * @param spanContext span context to be wrapped
   */
  function setSpanContext(context, spanContext) {
      return setSpan(context, new NonRecordingSpan(spanContext));
  }
  /**
   * Get the span context of the span if it exists.
   *
   * @param context context to get values from
   */
  function getSpanContext(context) {
      var _a;
      return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  const VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
  }
  function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
  }
  /**
   * Returns true if this {@link SpanContext} is valid.
   * @return true if this {@link SpanContext} is valid.
   */
  function isSpanContextValid(spanContext) {
      return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
  }
  /**
   * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
   *
   * @param spanContext span context to be wrapped
   * @returns a new non-recording {@link Span} with the provided context
   */
  function wrapSpanContext(spanContext) {
      return new NonRecordingSpan(spanContext);
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const contextApi = ContextAPI.getInstance();
  /**
   * No-op implementations of {@link Tracer}.
   */
  class NoopTracer {
      // startSpan starts a noop span.
      startSpan(name, options, context = contextApi.active()) {
          const root = Boolean(options === null || options === undefined ? undefined : options.root);
          if (root) {
              return new NonRecordingSpan();
          }
          const parentFromContext = context && getSpanContext(context);
          if (isSpanContext(parentFromContext) &&
              isSpanContextValid(parentFromContext)) {
              return new NonRecordingSpan(parentFromContext);
          }
          else {
              return new NonRecordingSpan();
          }
      }
      startActiveSpan(name, arg2, arg3, arg4) {
          let opts;
          let ctx;
          let fn;
          if (arguments.length < 2) {
              return;
          }
          else if (arguments.length === 2) {
              fn = arg2;
          }
          else if (arguments.length === 3) {
              opts = arg2;
              fn = arg3;
          }
          else {
              opts = arg2;
              ctx = arg3;
              fn = arg4;
          }
          const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
          const span = this.startSpan(name, opts, parentContext);
          const contextWithSpanSet = setSpan(parentContext, span);
          return contextApi.with(contextWithSpanSet, fn, undefined, span);
      }
  }
  function isSpanContext(spanContext) {
      return (typeof spanContext === 'object' &&
          typeof spanContext['spanId'] === 'string' &&
          typeof spanContext['traceId'] === 'string' &&
          typeof spanContext['traceFlags'] === 'number');
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const NOOP_TRACER = new NoopTracer();
  /**
   * Proxy tracer provided by the proxy tracer provider
   */
  class ProxyTracer {
      constructor(_provider, name, version, options) {
          this._provider = _provider;
          this.name = name;
          this.version = version;
          this.options = options;
      }
      startSpan(name, options, context) {
          return this._getTracer().startSpan(name, options, context);
      }
      startActiveSpan(_name, _options, _context, _fn) {
          const tracer = this._getTracer();
          return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      }
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      _getTracer() {
          if (this._delegate) {
              return this._delegate;
          }
          const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
          if (!tracer) {
              return NOOP_TRACER;
          }
          this._delegate = tracer;
          return this._delegate;
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * An implementation of the {@link TracerProvider} which returns an impotent
   * Tracer for all calls to `getTracer`.
   *
   * All operations are no-op.
   */
  class NoopTracerProvider {
      getTracer(_name, _version, _options) {
          return new NoopTracer();
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const NOOP_TRACER_PROVIDER = new NoopTracerProvider();
  /**
   * Tracer provider which provides {@link ProxyTracer}s.
   *
   * Before a delegate is set, tracers provided are NoOp.
   *   When a delegate is set, traces are provided from the delegate.
   *   When a delegate is set after tracers have already been provided,
   *   all tracers already provided will use the provided delegate implementation.
   */
  class ProxyTracerProvider {
      /**
       * Get a {@link ProxyTracer}
       */
      getTracer(name, version, options) {
          var _a;
          return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer(this, name, version, options));
      }
      getDelegate() {
          var _a;
          return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
      }
      /**
       * Set the delegate tracer provider
       */
      setDelegate(delegate) {
          this._delegate = delegate;
      }
      getDelegateTracer(name, version, options) {
          var _a;
          return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
   * A sampling decision that determines how a {@link Span} will be recorded
   * and collected.
   */
  exports.SamplingDecision = void 0;
  (function (SamplingDecision) {
      /**
       * `Span.isRecording() === false`, span will not be recorded and all events
       * and attributes will be dropped.
       */
      SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
      /**
       * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
       * MUST NOT be set.
       */
      SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
      /**
       * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
       * MUST be set.
       */
      SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(exports.SamplingDecision || (exports.SamplingDecision = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  exports.SpanKind = void 0;
  (function (SpanKind) {
      /** Default value. Indicates that the span is used internally. */
      SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
      /**
       * Indicates that the span covers server-side handling of an RPC or other
       * remote request.
       */
      SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
      /**
       * Indicates that the span covers the client-side wrapper around an RPC or
       * other remote request.
       */
      SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
      /**
       * Indicates that the span describes producer sending a message to a
       * broker. Unlike client and server, there is no direct critical path latency
       * relationship between producer and consumer spans.
       */
      SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
      /**
       * Indicates that the span describes consumer receiving a message from a
       * broker. Unlike client and server, there is no direct critical path latency
       * relationship between producer and consumer spans.
       */
      SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
  })(exports.SpanKind || (exports.SpanKind = {}));

  /**
   * An enumeration of status codes.
   */
  exports.SpanStatusCode = void 0;
  (function (SpanStatusCode) {
      /**
       * The default status.
       */
      SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
      /**
       * The operation has been validated by an Application developer or
       * Operator to have completed successfully.
       */
      SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
      /**
       * The operation contains an error.
       */
      SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
  })(exports.SpanStatusCode || (exports.SpanStatusCode = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Split module-level variable definition into separate files to allow
  // tree-shaking on each api instance.
  /** Entrypoint for context API */
  const context = ContextAPI.getInstance();

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Split module-level variable definition into separate files to allow
  // tree-shaking on each api instance.
  /**
   * Entrypoint for Diag API.
   * Defines Diagnostic handler used for internal diagnostic logging operations.
   * The default provides a Noop DiagLogger implementation which may be changed via the
   * diag.setLogger(logger: DiagLogger) function.
   */
  const diag = DiagAPI.instance();

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * An implementation of the {@link MeterProvider} which returns an impotent Meter
   * for all calls to `getMeter`
   */
  class NoopMeterProvider {
      getMeter(_name, _version, _options) {
          return NOOP_METER;
      }
  }
  const NOOP_METER_PROVIDER = new NoopMeterProvider();

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const API_NAME$2 = 'metrics';
  /**
   * Singleton object which represents the entry point to the OpenTelemetry Metrics API
   */
  class MetricsAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() { }
      /** Get the singleton instance of the Metrics API */
      static getInstance() {
          if (!this._instance) {
              this._instance = new MetricsAPI();
          }
          return this._instance;
      }
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      setGlobalMeterProvider(provider) {
          return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
      }
      /**
       * Returns the global meter provider.
       */
      getMeterProvider() {
          return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
      }
      /**
       * Returns a meter from the global meter provider.
       */
      getMeter(name, version, options) {
          return this.getMeterProvider().getMeter(name, version, options);
      }
      /** Remove the global meter provider */
      disable() {
          unregisterGlobal(API_NAME$2, DiagAPI.instance());
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Split module-level variable definition into separate files to allow
  // tree-shaking on each api instance.
  /** Entrypoint for metrics API */
  const metrics = MetricsAPI.getInstance();

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * No-op implementations of {@link TextMapPropagator}.
   */
  class NoopTextMapPropagator {
      /** Noop inject function does nothing */
      inject(_context, _carrier) { }
      /** Noop extract function does nothing and returns the input context */
      extract(context, _carrier) {
          return context;
      }
      fields() {
          return [];
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Baggage key
   */
  const BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
  /**
   * Retrieve the current baggage from the given context
   *
   * @param {Context} Context that manage all context values
   * @returns {Baggage} Extracted baggage from the context
   */
  function getBaggage(context) {
      return context.getValue(BAGGAGE_KEY) || undefined;
  }
  /**
   * Retrieve the current baggage from the active/current context
   *
   * @returns {Baggage} Extracted baggage from the context
   */
  function getActiveBaggage() {
      return getBaggage(ContextAPI.getInstance().active());
  }
  /**
   * Store a baggage in the given context
   *
   * @param {Context} Context that manage all context values
   * @param {Baggage} baggage that will be set in the actual context
   */
  function setBaggage(context, baggage) {
      return context.setValue(BAGGAGE_KEY, baggage);
  }
  /**
   * Delete the baggage stored in the given context
   *
   * @param {Context} Context that manage all context values
   */
  function deleteBaggage(context) {
      return context.deleteValue(BAGGAGE_KEY);
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const API_NAME$1 = 'propagation';
  const NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
  /**
   * Singleton object which represents the entry point to the OpenTelemetry Propagation API
   */
  class PropagationAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
          this.createBaggage = createBaggage;
          this.getBaggage = getBaggage;
          this.getActiveBaggage = getActiveBaggage;
          this.setBaggage = setBaggage;
          this.deleteBaggage = deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      static getInstance() {
          if (!this._instance) {
              this._instance = new PropagationAPI();
          }
          return this._instance;
      }
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      setGlobalPropagator(propagator) {
          return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
      }
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      inject(context, carrier, setter = defaultTextMapSetter) {
          return this._getGlobalPropagator().inject(context, carrier, setter);
      }
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      extract(context, carrier, getter = defaultTextMapGetter) {
          return this._getGlobalPropagator().extract(context, carrier, getter);
      }
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      fields() {
          return this._getGlobalPropagator().fields();
      }
      /** Remove the global propagator */
      disable() {
          unregisterGlobal(API_NAME$1, DiagAPI.instance());
      }
      _getGlobalPropagator() {
          return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Split module-level variable definition into separate files to allow
  // tree-shaking on each api instance.
  /** Entrypoint for propagation API */
  const propagation = PropagationAPI.getInstance();

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const API_NAME = 'trace';
  /**
   * Singleton object which represents the entry point to the OpenTelemetry Tracing API
   */
  class TraceAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
          this._proxyTracerProvider = new ProxyTracerProvider();
          this.wrapSpanContext = wrapSpanContext;
          this.isSpanContextValid = isSpanContextValid;
          this.deleteSpan = deleteSpan;
          this.getSpan = getSpan;
          this.getActiveSpan = getActiveSpan;
          this.getSpanContext = getSpanContext;
          this.setSpan = setSpan;
          this.setSpanContext = setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      static getInstance() {
          if (!this._instance) {
              this._instance = new TraceAPI();
          }
          return this._instance;
      }
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      setGlobalTracerProvider(provider) {
          const success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
          if (success) {
              this._proxyTracerProvider.setDelegate(provider);
          }
          return success;
      }
      /**
       * Returns the global tracer provider.
       */
      getTracerProvider() {
          return getGlobal(API_NAME) || this._proxyTracerProvider;
      }
      /**
       * Returns a tracer from the global tracer provider.
       */
      getTracer(name, version) {
          return this.getTracerProvider().getTracer(name, version);
      }
      /** Remove the global tracer provider */
      disable() {
          unregisterGlobal(API_NAME, DiagAPI.instance());
          this._proxyTracerProvider = new ProxyTracerProvider();
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Split module-level variable definition into separate files to allow
  // tree-shaking on each api instance.
  /** Entrypoint for trace API */
  const trace = TraceAPI.getInstance();

  exports.INVALID_SPANID = INVALID_SPANID;
  exports.INVALID_SPAN_CONTEXT = INVALID_SPAN_CONTEXT;
  exports.INVALID_TRACEID = INVALID_TRACEID;
  exports.ProxyTracer = ProxyTracer;
  exports.ProxyTracerProvider = ProxyTracerProvider;
  exports.ROOT_CONTEXT = ROOT_CONTEXT;
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
  exports.context = context;
  exports.createContextKey = createContextKey;
  exports.createNoopMeter = createNoopMeter;
  exports.defaultTextMapGetter = defaultTextMapGetter;
  exports.defaultTextMapSetter = defaultTextMapSetter;
  exports.diag = diag;
  exports.global = global$1;
  exports.isSpanContextValid = isSpanContextValid;
  exports.isValidSpanId = isValidSpanId;
  exports.isValidTraceId = isValidTraceId;
  exports.metrics = metrics;
  exports.propagation = propagation;
  exports.trace = trace;

}));
